#include "wiskunde.h"


//********************************************************************************//
//********************************************************************************//
// Wiskunde functies
//********************************************************************************//
//********************************************************************************//


////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
float Wiskunde::PI()
{
	return 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067f;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
float Wiskunde::RAD2DEG(float radiant)
{
	return radiant * 180 / PI();
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
float Wiskunde::DEG2RAD(float degrees)
{
	return degrees * PI() / 180;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Wiskunde::GetNormal(Vector V1, Vector V2, Vector V3)
{
	Vector Vec1 = V2.Vectorize(V1);
	Vector Vec2 = V2.Vectorize(V3);

	Vector Normal = Wiskunde::Cross(Vec1, Vec2);

	Normal.Normalize();

	return Normal;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Wiskunde::Cross(Vector V1, Vector V2)
{
	return Vector(	(V1.Y * V2.Z) - (V1.Z * V2.Y),
					(V1.Z * V2.X) - (V1.X * V2.Z),
					(V1.X * V2.Y) - (V1.Y * V2.X));
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Wiskunde::Normalize(Vector V)
{
	float magnitude = V.Magnitude();

	return Vector(V / magnitude);
}



	











//********************************************************************************//
//********************************************************************************//
// Vector class met functies
//********************************************************************************//
//********************************************************************************//


////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector::Vector()
{
	this->X = 0.0f;
	this->Y = 0.0f;
	this->Z = 0.0f;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector::Vector(float X, float Y, float Z)
{
	this->X = X;
	this->Y = Y;
	this->Z = Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::Fill(float X, float Y, float Z)
{
	this->X = X;
	this->Y = Y;
	this->Z = Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::Vectorize(Vector V)
{
	return Vector(X - V.X, Y - V.Y, Z - V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::Normalize()
{
	float magnitude = Magnitude();

	*this = *this / magnitude;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
float Vector::Magnitude()
{
	return (float)sqrt( (X * X) + 
						(Y * Y) + 
						(Z * Z) );
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator*=(Vector V)
{
	this->X *= V.X;
	this->Y *= V.Y;
	this->Z *= V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator*(Vector V)
{
	return Vector(X * V.X, Y * V.Y, Z * V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator*(float F)
{
	return Vector(X * F, Y * F, Z * F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator/=(Vector V)
{
	if( V.X == 0 || V.Y == 0 || V.Z == 0 )
		return;
	this->X /= V.X;
	this->Y /= V.Y;
	this->Z /= V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator/(Vector V)
{
	if( V.X == 0 || V.Y == 0 || V.Z == 0 )
		return Vector(0.0f, 0.0f, 0.0f);
	return Vector(X / V.X, Y / V.Y, Z / V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator/(float F)
{
	if ( F == 0 )
		return Vector(X, Y, Z);
	return Vector(X / F, Y / F, Z / F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator+=(Vector V)
{
	this->X += V.X;
	this->Y += V.Y;
	this->Z += V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator+(Vector V)
{
	return Vector(X + V.X, Y + V.Y, Z + V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator+(float F)
{
	return Vector(X + F, Y + F, Z + F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator-=(Vector V)
{
	this->X -= V.X;
	this->Y -= V.Y;
	this->Z -= V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator-(Vector V)
{
	return Vector(X - V.X, Y - V.Y, Z - V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator-(float F)
{
	return Vector(X - F, Y - F, Z - F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator=(Vector V)
{
	X = V.X;
	Y = V.Y;
	Z = V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
bool Vector::Equals(Vector V)
{
	if ( V.X == X && V.Y == Y && V.Z == Z )
		return true;
	return false;
}














//********************************************************************************//
//********************************************************************************//
// Matrix class met functies
//********************************************************************************//
//********************************************************************************//


////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Matrix::Matrix()
{
	FillIndentity();
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Matrix::Matrix(float N[][4])
{
	for ( int i = 0; i < 4; i++ )
	{
		for ( int j = 0; j < 4; j++ )
		{
			this->M[i][j] = N[i][j];
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : Fill the member matrix with the Identity Matrix
// Input   : -
// Output  : -
////////////////////////////////////////////////////////////////////////////////////
void Matrix::FillIndentity()
{
	for ( int i = 0; i < 4; i++ ) {
		for ( int j = 0; j < 4; j++ ) {
			if ( i == j )
				M[i][j] = 1;
			else
				M[i][j] = 0;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Matrix::FillZero()
{
	for ( int i = 0; i < 4; i++ ) {
		for ( int j = 0; j < 4; j++ ) {
			M[i][j] = 0;
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Matrix::Fill(float N[][4])
{
	for ( int i = 0; i < 4; i++ )
	{
		for ( int j = 0; j < 4; j++ )
		{
			this->M[i][j] = N[i][j];
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Matrix::Get(float N[][4])
{
	for ( int i = 0; i < 4; i++ )
	{
		for ( int j = 0; j < 4; j++ )
		{
			N[i][j] = this->M[i][j];
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
const float Matrix::At(int i, int j)
{
	return M[i][j];
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Matrix Matrix::operator*(Matrix M)
{
	float N[4][4];

	N[0][0] =	(this->M[0][0] * M.M[0][0]) + (this->M[0][1] * M.M[1][0]) +
					(this->M[0][2] * M.M[2][0]) + (this->M[0][3] * M.M[3][0]);

	N[0][1] =	(this->M[0][0] * M.M[0][1]) + (this->M[0][1] * M.M[1][1]) +
					(this->M[0][2] * M.M[2][1]) + (this->M[0][3] * M.M[3][1]);

	N[0][2] =	(this->M[0][0] * M.M[0][2]) + (this->M[0][1] * M.M[1][2]) +
					(this->M[0][2] * M.M[2][2]) + (this->M[0][3] * M.M[3][2]);

	N[0][3] =	(this->M[0][0] * M.M[0][3]) + (this->M[0][1] * M.M[1][3]) +
					(this->M[0][2] * M.M[2][3]) + (this->M[0][3] * M.M[3][3]);


	N[1][0] =	(this->M[1][0] * M.M[0][0]) + (this->M[1][1] * M.M[1][0]) +
					(this->M[1][2] * M.M[2][0]) + (this->M[1][3] * M.M[3][0]);

	N[1][1] =	(this->M[1][0] * M.M[0][1]) + (this->M[1][1] * M.M[1][1]) +
					(this->M[1][2] * M.M[2][1]) + (this->M[1][3] * M.M[3][1]);

	N[1][2] =	(this->M[1][0] * M.M[0][2]) + (this->M[1][1] * M.M[1][2]) +
					(this->M[1][2] * M.M[2][2]) + (this->M[1][3] * M.M[3][2]);

	N[1][3] =	(this->M[1][0] * M.M[0][3]) + (this->M[1][1] * M.M[1][3]) +
					(this->M[1][2] * M.M[2][3]) + (this->M[1][3] * M.M[3][3]);


	N[2][0] =	(this->M[2][0] * M.M[0][0]) + (this->M[2][1] * M.M[1][0]) +
					(this->M[2][2] * M.M[2][0]) + (this->M[2][3] * M.M[3][0]);

	N[2][1] =	(this->M[2][0] * M.M[0][1]) + (this->M[2][1] * M.M[1][1]) +
					(this->M[2][2] * M.M[2][1]) + (this->M[2][3] * M.M[3][1]);

	N[2][2] =	(this->M[2][0] * M.M[0][2]) + (this->M[2][1] * M.M[1][2]) +
					(this->M[2][2] * M.M[2][2]) + (this->M[2][3] * M.M[3][2]);

	N[2][3] =	(this->M[2][0] * M.M[0][3]) + (this->M[2][1] * M.M[1][3]) +
					(this->M[2][2] * M.M[2][3]) + (this->M[2][3] * M.M[3][3]);


	N[3][0] =	(this->M[3][0] * M.M[0][0]) + (this->M[3][1] * M.M[1][0]) +
					(this->M[3][2] * M.M[2][0]) + (this->M[3][3] * M.M[3][0]);

	N[3][1] =	(this->M[3][0] * M.M[0][1]) + (this->M[3][1] * M.M[1][1]) +
					(this->M[3][2] * M.M[2][1]) + (this->M[3][3] * M.M[3][1]);

	N[3][2] =	(this->M[3][0] * M.M[0][2]) + (this->M[3][1] * M.M[1][2]) +
					(this->M[3][2] * M.M[2][2]) + (this->M[3][3] * M.M[3][2]);

	N[3][3] =	(this->M[3][0] * M.M[0][3]) + (this->M[3][1] * M.M[1][3]) +
					(this->M[3][2] * M.M[2][3]) + (this->M[3][3] * M.M[3][3]);

	return Matrix(N);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Matrix Matrix::operator/(Matrix M)
{
	return Matrix();
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Matrix Matrix::operator+(Matrix M)
{
	return Matrix();
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Matrix Matrix::operator-(Matrix M)
{
	return Matrix();
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
float *Matrix::operator[]( int i )
{
	if (( i >= 0 ) && ( i < 4 ))
		return M[i];
	else
		return 0;
}
////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
bool Matrix::Equals(Matrix M)
{
	for ( int i = 0; i < 4; i++ ) {
		for ( int j = 0; j < 4; j++ ) {
			if ( this->M[i][j] != M.At(i,j) )
				return false;
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::MatrixTranslate(Vector V)
{
	M[3][0] = -V.X;
	M[3][1] = -V.Y;
	M[3][2] = -V.Z;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::MatrixTranslateInv(Vector V)
{
	M[0][3] = -V.X;
	M[1][3] = -V.Y;
	M[2][3] = -V.Z;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::MatrixScale(Vector V)
{
	M[0][0] = V.X;
	M[1][1] = V.Y;
	M[2][2] = V.Z;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::MatrixRotateXDeg(float X)
{
	M[1][1] = cosf( Wiskunde::DEG2RAD(X) );
	M[1][2] = sinf( Wiskunde::DEG2RAD(X) );
	M[2][1] = -sinf( Wiskunde::DEG2RAD(X) );
	M[2][2] = cosf( Wiskunde::DEG2RAD(X) );
/*
	[ 1,         0,          0, 0]
	[ 0, cos(xrot),  sin(xrot), 0]
	[ 0,-sin(xrot),  cos(xrot), 0]
	[ 0,         0,          0, 1]
*/
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::MatrixRotateYDeg(float Y)
{
	M[0][0] = cosf( Wiskunde::DEG2RAD(Y) );
	M[0][2] = -sinf( Wiskunde::DEG2RAD(Y) );
	M[2][0] = sinf( Wiskunde::DEG2RAD(Y) );
	M[2][2] = cosf( Wiskunde::DEG2RAD(Y) );
/*
	[ cos(yrot), 0,-sin(yrot), 0]
	[         0, 1,         0, 0]
	[ sin(yrot), 0, cos(yrot), 0]
	[         0, 0,         0, 1]
*/
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::MatrixRotateZDeg(float Z)
{
	M[0][0] = cosf( Wiskunde::DEG2RAD(Z) );
	M[0][1] = sinf( Wiskunde::DEG2RAD(Z) );
	M[1][0] = -sinf( Wiskunde::DEG2RAD(Z) );
	M[1][1] = cosf( Wiskunde::DEG2RAD(Z) );
/*
	[ cos(zrot),  sin(zrot), 0, 0]
	[-sin(zrot),  cos(zrot), 0, 0]
	[         0,          0, 1, 0]
	[         0,          0, 0, 1]
*/
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Matrix::TransPose()
{
	float fTemp;

	fTemp = M[0][1];
	M[0][1] = M[1][0];
	M[1][0] = fTemp;

	fTemp = M[0][2];
	M[0][2] = M[2][0];
	M[2][0] = fTemp;

	fTemp = M[0][3];
	M[0][3] = M[3][0];
	M[3][0] = fTemp;

	fTemp = M[1][2];
	M[1][2] = M[2][1];
	M[2][1] = fTemp;

	fTemp = M[1][3];
	M[1][3] = M[3][1];
	M[3][1] = fTemp;

	fTemp = M[2][3];
	M[2][3] = M[3][2];
	M[3][2] = fTemp;
}














//********************************************************************************//
//********************************************************************************//
// Color class met functies
//********************************************************************************//
//********************************************************************************//


////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
Color::Color()
{
	this->R = 0.0f;
	this->G = 0.0f;
	this->B = 0.0f;
	this->A = 1.0f;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
Color::Color(float r, float g, float b)
{
	this->R = r;
	this->G = g;
	this->B = b;
	this->A = 1.0f;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
Color::Color(float r, float g, float b, float a)
{
	this->R = r;
	this->G = g;
	this->B = b;
	this->A = a;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Color::Set(float r, float g, float b)
{
	this->R = r;
	this->G = g;
	this->B = b;
	this->A = 1.0f;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Color::Set(float r, float g, float b, float a)
{
	this->R = r;
	this->G = g;
	this->B = b;
	this->A = a;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Color::Set(COLORREF color)
{
	this->R = GetRValue(color);
	this->G = GetGValue(color);
	this->B = GetBValue(color);
	this->A = 1.0f;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Color::Set(float color[])
{
	this->R = color[0];
	this->G = color[1];
	this->B = color[2];
	this->A = 1.0f;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
float Color::GetR()
{
	return this->R;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
float Color::GetG()
{
	return this->G;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
float Color::GetB()
{
	return this->B;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
float Color::GetA()
{
	return this->A;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
COLORREF Color::Get()
{
	return RGB(255 * this->R, 255 * this->G, 255 * this->B);
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
void Color::Get(float color[])
{
	color[0] = this->R;
	color[1] = this->G;
	color[2] = this->B;
	color[3] = this->A;
}

////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////
float* Color::GetP()
{
	float* color = new float[4];
	color[0] = this->R;
	color[1] = this->G;
	color[2] = this->B;
	color[3] = this->A;

	return color;
}
